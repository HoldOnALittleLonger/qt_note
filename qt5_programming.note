QT5

//  example source code was contained in the directory which has same name.
//  more methods for a class is defined in header.

Chapter 1 : Hello World
    #include<QtWidgets/QApplication>
    #include<QtWidgets/QLabel>

    int main(int argc, char *argv[])
    {
      QApplication app(argc, argv);
      QLabel label("Hello World");
      label.show();
      return QApplication::exec();
    }
      

Chapter 2 : Creating Widgets and Layouts
    Widgets :
      Widgets are the graphical components with which we construct user interfaces.
      Information is passed to widgets by way of events.(e.g. textbox)

      Every widget can have a parent widget or children widgets,and widgets that do not have a parent
      widget become a window when the show() function is called on them.

      Figure of Qt programming classes inheritance : (TOP -> BOTTON)
        QObject
	  (QThread, QWidget)
	  	    QWidget
		      (QAbstractButton, QFrame, QProgressBar)
		      QAbstractButton
		        (QCheckBox, QPushButton, QRadioButton)
		      QFrame
		        (QAbstractScrollArea, QLabel)
			QAbstractScrollArea
			  (QGraphicsView, QTextEdit)

      #  class QWidget : <inherit method> QObject
      #  class QLabel : public QFrame
      #  ...

      QObject class contains the mechanisms of signals and slots and event management and etc.
      A lot of classes inherit from QObject.

      QWidget class contains the shared common behavior are grouped together.

      QCheckBox QPushButton QRadioButton are all buttons of the same kind and inherit from QAbstractButton.

      QAbstractButton holds properties and functions that are shared by all buttons,this principle also
      applies to QAbstractScrollArea and QGraphicsView and QTextEdit.

      #  if unspecified parent widget for a widget,then its parent widget would be setted to NULL(no parent).
      #  when displaying such a widget,it will be enclosed in a window on account of this reasoning.

      Functions and Type :
        Class QString : <QtCore/QString>
          QString is a class for the case when working with strings.
	  It has a host of functionalities not avaiable in C++ string.

	Class QFont : <QtGui/QFont>
	  Qt program font setting controller.

	class QWidget::
	  void setToolTip(const QString &);
	    set tip text for widget.

	  void setFont(const QFont &);
	    set font to the label for display.

	class QLabel::
	  void setAlignment(Qt::Alignment);
	    set alignment for the label when displaying.

	Qt::AlignCenter :
	  a constant to specify center align.

    Layout :
      Layout inheritance :
        QObject QLayoutItem  <QLayoutItem is a abstract base class>
	  (QLayout          )
	  QLayout
	    (QBoxLayout, QFormLayout, QGridLayout, QStackedLayout)
	    QBoxLayout
	      (QHBoxLayout, QVBoxLayout)

        QFormLayout class manages forms of input widgets and their associated labels.
	QGridLayout class lays out widgets in a grid.
	QStackedLayout class provides a stack of widgets where only one widget is visible at a time.
	QVBoxLayout class lines up widgets vertically.
	QHBoxLayout class lines up widgets horizontally.

	//  Layout could contains another Layout.
	
	Reasons for need layout :
	  1>  to allow us to display more than one widget.
	  2>  to present the many widgets in our interface nicely and intuitively to allow
	      the UI to be useful.

      QGridLayout :
        QGridLayout is used to arrange widgets by specifying the number of rows and columns that will be
	filled up by multiple widgets.

	it has style like this chart :
	  <string(head field)> <widget1> ... 
	  ...
	  <string(head field)> <widget1> ... 
	
	//  qgridlayout produces grid layout in another words is grid table.
	

        Functions and Type : 
	  Class QLayoutItem : <QtWidgets/QLayoutItem>
	    This class as abstract base class in hierarchy.
	    class QLayout public inherit from it.

          Class QGridLayout : <QtWidgets/QGridLayout>
	    This class public inherit from QLayout.It can make table style layout for qt program.
	    
	  class QGridLayout::
	    inline void addWidget(QWidget *w);
	    void addWidget(QWidget *, int row, int column, Qt::Alignment = Qt::Alignment());
	    void addWidget(QWidget *, int row, int column, int rowSpan, int columnSpan);
	      addWidget() method add a QtWidget into QGridLayout,the items would be arranged with table style.
	      the widget was added how to stretch out is conform to the arguments rowSpan and columnSpan.

	  Class QWidget : <QtWidgets/QWidget>
	    This class is the qt widget in hierarchy.

	  class QWidget::
	    void setLayout(QLayout *);
	      setLayout() method put a QLayout in QWidget.can declare a QWidget then put layout in it,and
	      call show() to let it becomes a main window.

	  Class QLineEdit : <QtWidgets/QLineEdit>
	    this class provides the featrue of edit text on line(i/o box).
	    //  could set echo mode for QLineEdit,it supports :
	    //    Normal, NoEcho, Password, PasswordEchoOnEdit
	    //  via invoke void setEchoMode(EchoMode);
	    //  via invoke void setPlaceholderText(const QString &); could place hint text on line.

	    QString text() const;
	      this method returns the string received by QLineEdit object.
	    void setText(const QString &);
	      this method set current text in QLineEdit to the QString refers to.  

	  Class QSpinBox : <QtWidgets/QSpinBox>
	    this class provides spin box that is the qt widget,user can use mouse to select a number
	    from the given range eazily.
	    //  void setRange(start, end); [start, end]

	  Class QComboBox : <QtWidgets/QComboBox>
	    this class provides combobox the qt widget,user can select string from the pre-defined texts.

	  class QCombox::
	    inline void addItems(const QStringList &texts);
	      addItems() method add qt string list to combobox.

	  Class QStringList : <QtCore/QStringList>
	    this class is alike at c++ stl vector that is type of std::vector<std::string>.

      QFormLayout :
        It can simply place a number of widgets together in a two-column layout.
	The layout it could made is like this chart :
	  <string> | <widget>
	  ...        ...
	  name       <QLineEdit>
	  ...        ...

        //  qformlayout produces form layout in another words is key-value table.	    

        Functions and Type :
	  class QFormLayout : public QLayout; <QtWidgets/QFormLayout>

	  class QFormLayout :
	    void addRow(QWidget *label, QWidget *field);
	    void addRow(QWidget *label, QLayout *field);
	    void addRow(const QString &labelText, QWidget *field);
	    void addRow(const QString &labelText, QLayout *field);
	    void addRow(QWidget *widget);
	    void addRow(QLayout *layout);
	      addRow() methods add a row to layout.

	    void insertRow(int row, QWidget *label, QWidget *field);
	    void insertRow(int row, QWidget *label, QLayout *field);
	    void insertRow(int row, const QString &labelText, QWidget *field);
	    ...
	      insertRow() methods can insert a row after the specified row.

	    void removeRow(int row);
	    void removeRow(QWidget *widget);
	    void removeRow(QLayout *layout);
	      removeRow() methods remove a row from qformlayout.

	    void setLabelAlignment(Qt::Alignment alignment);
	    void setFormAlignment(Qt::Alignment alignment);
	    Qt::Alignment labelAlignment() const;
	    Qt::Alignment formAlignment() const;
	      how to align label and field.

	    //  more methods in header.
      
      Layouts with direction :
        some layouts that provide direction of growth when widgets are added to them,
	and could set alignment for all widgets in a layout horizontally or vertically.

      QVBoxLayout :
        all widgets added into QVBoxLayout are aligned vertically and they are packed in the layout
	from top to bottom.
	the style is like this chart :
	  --  top     --  
	  <widget1>
	  <widget2>
	  <widget3>
	  ...
	  --  bottom  --

        Functions and Type :
	  class QVBoxLayout : public QBoxLayout;  <QtWidgets/QVBoxLayout>
	  class QBoxLayout : public QLayout;      <QtWidgets/QBoxLayout>

	  class QBoxLayout :
	    Direction direction() const;
	    void setDirection(Direction);
	    enum Direction { LeftToRight, RightToLeft, TopToBottom,
	    	 	     BottomToTop, Down = TopToBottom, Up = BottomToTop};
	      direction control.

	    void addWidget(QWidget *, int stretch  = 0, Qt::Alignment alignment = Qt::Alignment());
	      add a QtWidget into BoxLayout.

	    void addLayout(QLayout *layout, int stretch = 0);
	      add a QtLayout into BoxLayout.

	    void addItem(QLayoutItem *) override;
	      add QLayoutItem into BoxLayout.


      QHBoxLayout :
        QHBoxLayout is similar as QVBoxLayout but it is stretch horizontally.
	it packs layout through left to right or right to left.
	the style is like this chart :
	  |    |			|Right|
	  |Left|<Widget1> <Widget2> ... |Right|
	  |    |	  	    	|Right|

	Functions and Type :
	  class QHBoxLayout : public QBoxLayout;  <QtWidgets/QHBoxLayout>
	    it hasnt internal methods exclude constructor and destructor.all methods inherited from QBoxLayout.

	  void addStretch(int stretch = 0);  //  inherited from QBoxLayout class.
	    add stretch to current QHBoxLayout object.stretch was filled by empty space.


Chapter 3 : Working with Signals and Slots
    Improve the usable to application,have to use signal check its status to prevent some wrong case.
    Understanding the concept behind signals and slots Learning the different ways to connect singals and slots.

    Every action is happened would be registered,and provided ample code has been written,it will be executed as a
    reaction.
    One way to implement the ability to react to an action that has occurred is by using the design pattern called
    the "Observer Pattern".

    Observer Pattern :
      an observable object communicates its state change to other objects that are observing it.
      A : object be observed
      B : object it observing A

      if B want to be notified of a state change of A,it first has to identify that object(A) and register itself(B) as one
      of the objects that should receive such notification of the state change.
      while A' state changed,A would notify the objects in a list all object each want to be notified by A for 
      state change.

    Signals and Slots :
      In Qt,action-response scheme is handled by signals and slots.
      
      Signal :
        A signal is a message that is passed to communicate that the state of an object has changed.
	This message may carry information about the change that has occurred.
	Sometimes,a signal may carry no extra information such as a button click.

      Slot :
        A slot is a specific function of an object that is called whenever a certain signal has been emitted.
	(alike of linux signal handle function)

      #  Signals and slots have to be connected(in code).Without writing code to connect a signal and a slot,
         they will exist as independent entities.
	 Most of widgets in Qt come with a number of signals and slots,but there could customise user-defined
	 signals and slots.

      For to connect signal and slot,have to call a static method connect() in QObject.
      It takes four arguments,
        a1 -> pointer of Object A - observed object
	a2 -> Signal              - signal A would deliver
	a3 -> pointer of Object B - observing object
	a4 -> Slot                - reaction while B received the signal @a2

        <QtCore/QObject>
        static QMetaObject::Connection connect(const QObject *sender, const char *signal,
	       			       	       const QObject *receiver, const char *method,
					       Qt::ConnectionType = Qt::AutoConnection);
        static QMetaObject::Connection connect(const QObject *sender, const QMetaMethod &signal,
	       			       	       const QObject *receiver, const QMetaMethod &method,
					       Qt::ConnectionType = Qt::AutoConnection);
	inline QMetaObject::Connection connect(const QObject *sender, const char *signal,
	       			       	       const char *member, Qt::ConnectionType = Qt::AutoConnection) const;

        //  these is some general member functions,but in other case,the QObject class declared some
	    function templates.

	!!   QWidget is derived from QObject.
	//  class QMetaMethod is declared in header <QtCore/QMetaObject>
	//  member method clicked() is declared in class QAbstractButton which in the header <QtWidgets/QAbstractButton>
	//  the slot quit() is declared in class QCoreApplication which in the header <QtCore/QCoreApplication>
	//  macro function SIGNAL() and SLOT() are declared in <QtCore/qobjectdefs.h>

      <QtWidgets/QDial>
        QDial widget is a knob-like looking widget that is graduated with a minium and maximnum range of  numbers.
        With the aid of a mouse,the knob can be turned,just like the volume on a speaker or radio.

        class QDial is derived from class QAbstractSlider in public.
	
      For to connect several slots to a signal by call QObject::connect method.
      When such signal was delivered,every slot was connected by QObject::connect would be executed.      
      //
        connect(A, SA, B, SLOTB)
	connect(A, SA, C, SLOTC)
	...

      #  generally,the signals of a widget class is declared in its class declaring under label 'Q_SIGNALS'.
      	 and the slots are supported is declared under label 'public Q_SLOTS'.

      <QtWidgets/QLCDNumber>
        QLCDNumber widget is a lcd-screen-like looking widget that display number information on the screen.
	this class is derived from class QFrame in public.
	and it supports these display mode : Hex, Dec, Oct, Bin
	supports segment style : Outline, Filled, Flat

      Of course,there could has single slot,multiple signals.
      For connect several signals to one slot,have to call QObject::connect method by repeat.
      but in this case,the fourth parameter of connect() is always same slot,and the third parameter of connect()
      is always same widget object.
      //  
        connect(A, SA, B, SLOTB)
	connect(C, SC, B, SLOTB)

      <QtWidgets/QSlider>
        QSlider is a slider widget.
	class QSlider is derived from class QAbstractSlider in public.
	QSlider allows to set ticks position,it supports :
	  NoTicks =0 , TicksAbove = 1, TicksLeft = TicksAbove, TicksBelow = 2, TicksRight = TicksBelow, TicksBothSides = 3

	but this class only allows to set orientation during construting.
	member method void setTickInterval(int ti); can set ticks interval.
	derived member method int singleStep() const; can set spaning for one step on ticks.


Chapter 4 : Implementing Windows and 4 Dialog
    Creating a custom window :
      for create a custom window,can make a new subclass it is derived from other QT class,so the new subclass
      for custom window should derived from QMainWindow.(QMainWindow is public inherit QWidget)

      Have to pay attention when try to define the subclass,the macro keyword Q_OBJECT should be contained in it.
      C++ does not know how to make connection between QT signal and QT slot,this macro could let signal-slot
      mechanism become a part of C++ syntax.(in another certain words,that is QT C++ syntax)

      the subclass define should like this following :
        class Subclass : public QMainWindow {
	
	  Q_OBJECT
	  public:
	    Subclass() { ... }
	    ...
	};

      <QtWidgets/QMainWindow>
      class QMainWindow : public QWidget;
        QMainWindow is used to create a Qt main window which is like to a editor window.
	  [  Menu Bar  ]
	    [  Toolbars  ]
	      [  Dock widgets  ]
	        [  Central widget  ]
		  ...
          [  Status Bar  ]

	Menu Bar : the top widget,such as the file,edit,and help menus go there.
	Toolbars : some tools go there.
	Dock widgets : some collapsible panels go there.
	Central widget : the main controls within the window must put in the Central Widget location,
		         could create a parent window put it in Central Widget location,and let some
			 functional child widgets in it.
			 the widget is Central widget would be the only widget to be displayed in 
			 QMainWindow.
	Status Bar : record somethings for current window.

	Methods :
	  void setCentralWidget(QWidget *widget);
	    this method lets the widget pointer widget points to becomes the central widget of current
	    QMainWindow object.

	  void resize(int w, int h);
	  void resize(const QSize &);
	    method resize is derived from base class QWidget.it resize window to to such window that
	    width == w and height == h (unit - pixel).
	    the overload would resize window to new size indicated by a QSize parameter.

    Menu bar :
      in Qt,menu bars occupy the very top of the window,for creat menu have to use class QMenu.
      for add some items in to a menu,have to use class QAction.of course,class QMenuBar is necessary.

      class QMainWindow has a member method named menuBar() :
        QMenuBar *QMainWindow::menuBar() const;
	  this method create a menubar at the top of main window.
	  a main window just has one menubar,but the menubar could has several submenu.

      class QMainWindow has a member method named addToolBar() :
        void addToolBar(Qt::ToolBarArea area, QToolBar *toolbar);
	void addToolBar(QToolBar *toolbar);
	QToolBar *addToolBar(const QString &title);
	  the functions func1 and func2 need an existed QToolBar object and place it in window.
	  the last function func3 needs a title text object and then create a QToolBar object
	  then return it.
	  in fact,func3 calls the first constructor of QToolBar class to create such object.
	  a main window could has one more tool bar in it.

      <QtWidgets/QMenuBar>
        class QMenuBar : public QWidget;
	  this class is a menu bar.a main window can only has one menu bar.

	Methods :
	  QAction *addMenu(QMenu *menu);
	  QMenu *addMenu(const QString &title);
	  QMenu *addMenu(const QIcon &icon, const QString &title);
	    addMenu() adds a menu to menu bar.there has several overload version.
	    QIcon is a class used to as an icon for menu or button.

      <QtWidgets/QMenu>
      class QMenu : public QWidget;
        this class is the meun in the menubar.

        Methods :
	  template<typename Functor>
	  QAction *addAction(const QIcon &icon, const QString &text, Functor functor, const QKeySequence &shortcut = 0);
	    addAction() takes four arguments.
	    @icon would be the new icon for the action in current meun.
	    @text would be describe text for the action.
	    @functor would be the object to invoke class featrues,generally is this pointer.
	    @shortcut is the shortcut for the action.QAction has member method setShortcut() to set shortcut after.

	  QAction *addSeparator();
	    add a separator into menu.

      <QtWidgets/QAction>
      class QAction : public QObject;
        this class is the action in the menu at its item.

	Methods :
	  void setShortcut(const QKeySequence &shortcut);
	    this method set shortcut for current QAction with QKeySequence.
	    the key compose is indicated by QKeySequence class.

	  void setShortcuts(QkeySequence::StandardKey);
	    this method is used to set StandardKey in Qt.

      so the relationship between these class is :
        (QMainWindow (QMenuBar
			(QMenu
			  QAction
			  QAction
			  ...)
			(QMenu
			  QAction
			  ...)
			...)
	             (QToolBar) ... )

      function QObject::connect() could connect singal and slot between QAction and QMainWindow.
      if some action is required by user,main window should respond as well.


    Tool bar :
      tool bar contains a set of controls that could be widgets or instance of QAction.
      this also means that may choose to replace the QAction with a widget,such as a regular QPushButton
      or QComboBox.
      generally,tool bar is beneath the menu bar,but there is could move it around the window.

      <QtWidgets/QToolBar>
      class QToolBar : public QWidget;
        this class is tool bar for Qt Application.

	Methods :
	  explicit QToolBar(const QString &title, QWidget *parent = nullptr);
	  explicit QToolBar(QWidget *parent = nullptr);
	    the constructors of QToolBar.

	  void setMoveable(bool movable);
	  bool isMovable() const;
	    setMoveable() is a toggler for controls whether the tool bar is movable.
	    isMovable() check the tool bar is movable or is not.

	  using QWidget::addAction;
	  QAction addAction(const QIcon &icon, const QString &text);
	    addAction() method is used to add QAction into the tool bar,and also there is some
	    overload version represented.
	    for this function,@icon is the image would shown on the button,and @text is the tooltip.
	    function returns a QAction object,and it can be used to make connection between signal
	    and slot via connect().

    Adding other widgets : 
      qt main window can only has one central widget,for to add central widget,have to call method
      void setCentralWidget(QWidget *widget);
      there is could place another qt widgets in the central widget to customize it.
      QGridLayout, QVBoxLayout, QHVBoxLayout, QMessageBox ...etc

      <QtWidgets/QTableView>
      class QTableView : public QAbstractItemView;
        this class use columns and rows to display data or information in cells.
	like this style :
	  [P00 P01 P02 ...]
	  [P10 P11 P12 ...]
	  ...
	table view style can has a model to introduce how display cell.
	  
	Methods :
	  void setModel(QAbstractItemModel *model) override;
	    set model for current table view object.

	  void setContextMenuPolicy(Qt::ContextMenuPolicy policy);  //  inherited from QWidget
	    set context menu policy for current table view object.

	  QHeaderView *horizontalHeader() const;
	  QHeaderView *verticalHeader() const;
	    these methods return pointers point to horizontal header or vertical header.
	    QHeaderView used to controls table' header style.

      //  Qt has QTableView class and QListView class and QTreeView class.
      	  QListView class in header <QtWidgets/QListView>,it used to display information alike of list style.
	  E.g.
	    [...]
	    [...]
	    [...]

	  QTreeView class in header <QtWidgets/QTreeView>,it used to display information alike of directory tree style.
	  (for hierarchical information)
	  E.g.
	    [...]
	      [...]
	        [...]
            [...]
	    ...

      <QtGui/QStandardItemModel>
      class QStandardItem;
      class QStandardItemModel : public QAbstractItemModel;
        QStandardItemModel is a class used to define compound format for items.
	QStandardItem is the item in QStandardItemModel.

	QStandardItemModel Methods :
	  QStandardItemModel(int rows, int columns, QObject *parent = nullptr);
	  explicit QStandardItemModel(QObject *parent = nullptr);
	    constructors.if give @rows and @columns,then the model produces a [@row, @columns] matrix
	    as its style.

	  QStandardItem *horizontalHeaderItem(int column) const;  
	  void setHorizontalHeaderItem(int column, QStandardItem *item);
	  QStandardItem *verticalHeaderItem(int row) const;
	  void setVerticalHeaderItem(int row, QStandardItem *item);
	    these functions is used to get or set header item.
	    one model just has one header,like table view.

	  QStandardItem *item(int row, int column = 0) const;
	  void setItem(int row, int column, QStandardItem *item);
	  inline void setItem(int row, QStandardItem *item);
	    these functions are used to insert item into model or get item from model.
	    header item must use header functions.

	QStandardItem Methods :
	  QStandardItem();
	  explicit QStandardItem(const QString &text);
	  QstandardItem(const QIcon &icon, const QString &text);
	  explicit QStandardItem(int rows, int columns = 1);
	    constructors,generally,the context of QStandardItem object is QString text.

	  inline QString text() const;
	    returns the current context in QStandardItem.

	  inline void setText(const QString &);
	    set the current context in QStandardItem to QString reference refers to.

      <QtCore/QDate>
      <QtWidgets/QDateEdit>
      <QtCore/QDateTime>
      class QDateEdit : public QDateTimeEdit;
      class QDate;
      class QDateTime;
        class QDate is a class used to save time style in Qt.
	class QDateEdit is a widget used to offer a interaction mechism between user and QDate on GUI.
	class QDateTime is similar to QDate,but it is not only contains date,just contains time as well.

	QDate Methods :
	  QDate();
	  QDate(int y, int m, int d);
	  QDate(int y, int m, int d, QCalender cal);
	    constructors used to construct QDate object.

	  int year() const;
	  int year(QCalender cal) const;
	  int month() const;
	  int month(QCalender cal) const;
	  int day() const;
	  int day(QCalender cal) const;
	  bool setDate(int year, int month, int day);
	  bool setDate(int year, int month, int day, QCalender cal);
	    these functions are used to get or set year,month,day.

	  static QDate currentDate();
	    returns a QDate object initialized by current system time.

	  QString toString(Qt::DateFormat format = Qt::TextDate) const;
	    convert current time data in QDate to a QString object and return it.

	QDateEdit Methods :
	  explicit QDateEdit(QWidget *parent = nullptr);
	  explicit QDateEdit(const QDate &date, QWidget *parent = nullptr);
	    constructors of QDateEdit.

	  QDate date() const;
	    returns QDate object initialized by current date received by QDateEdit object.

	  //  all features of QDateEdit are inherited from QDateTimeEdit.
	QDateTime Methods :
	  QDateTime() noexcept(Data::CanBeSmall);
	  QDateTime(const QDate &, const QTime &, Qt::TimeSpec spec = Qt::LocalTime);
	  QDateTime(const QDate &, const QTime &, Qt::TimeSpec spec, int offsetSeconds);
	  QDateTime(const QDate &, const QTime &, const QTimeZone &timeZone);
	    constructors

	  static QDateTime currentDateTime();
	  static QDateTime currentDatetimeUtc();
	    returns current date and time with local time zone or UTC date time.
	  

    Adding dialog boxes :
      QMessageBox provides us with the functionality to raise alerts and receive input using QInputDialog.
      Message type :
        Question :
	  For asking a question during normal operations.
	Information :
	  For reporting information about normal operations.
	Warning :
	  For reporting non-critical erros.
	Critical :
	  For reporting critical errors.

      The icon and number of buttons on a QMessageBox instance is configurable.

      <QtWidgets/QMessageBox>
      class QMessageBox : public QDialog;
        Qt message box class.

      Methods :
        explicit QMessageBox(QWidget *parent = nullptr);
	QMessageBox(Icon icon, const QString &title, const QString &text,
		    StandardButtons buttons = NoButton, QWidget *parent = nullptr,
		    Qt::WindowFlags flags = Qt::Dialog | Qt::MSWindowsFixedSizeDialogHint);

	  constructors of QMessageBox.
	  @buttons is the type of StandardButtons which is type of enumerator defined in QMessageBox.
	  there has some familiar buttons :
	    QMessageBox::Ok
	    QMessageBox::No
	    QMessageBox::NoButton  //  NoButton means no button produre
	    QMessageBox::Close
	    QMessageBox::Cancel
	    QMessageBox::Default   //  Default means the button is default button

	    //  tip text of button is the name of button.

	static int information(QWidget *parent, const QString &title, const QString &text,
	       	   	       int button0, int button1 = 0, int button2 = 0);
        static int information(QWidget *parent, const QString &title, const QString &text,
                               const QString &button0Text,
			       const QString &button1Text = QString(),
			       const QString &button2Text = QString(),
			       int defaultButtonNumber = 0,
			       int escapeButtonBumber = -1);
          information() method produce a inform message box.it could has three buttons in box.
	  if use the second overload version,then the tip text of button would be set as QString
	  object,pass null QString object would prevent produce the button.

        static StandardButton question(QWidget *parent, const QString &title, const QString &text,
	       		      	       StandardButtons buttons = StandardButtons(Yes | No),
				       StandardButton defaultButton = NoButton);
        static int question(QWidget *parent, const QString &title, const QString &text,
	       	            int button0, int button1 = 0, int button2 = 0);
        static int question(QWidget *parent, const QString &title, const QString &text,
	       	            QString &button0Text,
			    QString &button1Text = QString(),
			    QString &button2Text = QString(),
			    int defaultButtonNumber = 0,
			    int escapeButtonBumber = -1);
          question() method is used to raise a dialog to ask the user a question.it has two main buttons Yes and No,
	  and one alternative button(button2).
	  if user clicked @button0,returns 0,returns 1 when user clicked @button1,returns 2 when user clicked @button2.

	static void about(QWidget *parent, const QString &title, const QString &text);
	  about() method produces a about message box which has one button(Ok),and the message box has context @text.

	//  more in header.

      <QtWidgets/QInputDialog>
      class QInputDialog : public QDialog;
        the class is used to raise alerts to user and receive input from user.

      Methods :
        QInputDialog(QWidget *parent = nullptr, Qt::WindowFlags flags = Qt::WindowFlags());
	  constructor of QInputDialog.

	void setInputMode(InputMode mode);
	  set input mode one of TextInput,IntInput,DoubleInput.

	InputMode inputMode() const;
	  returns current input mode.

	void setLabelText(const QString &text);
	QString labelText() const;
	  set or get label text.

	void setOption(InputDialogOption option, bool on = true);
	bool testOption(InputDialogOption option) const;
	void setOptions(InputDialogOptions options);
	InputDialogOptions options() const;
	  set or test or get InputDialogOption for current object.
	  InputDialogOption is type of enumerator has value NoButtons,UseListViewForComboBoxItems,UsePlainTextEditForTextInput.

        static int getInt(QWidget *parent, const QString &title, const QString &label, int value = 0,
	       	          int minValue = -2147483647, int maxValue = 2147483647,
			  int step = 1, bool *ok = nullptr, Qt::WindowFlags flags = Qt::WindowFlags());
          getInt() would produce a combo box,it has one button Ok.
	  @value is the default value,
	  scope is [@minValue, @maxValue],
	  @step introduces increament for one step,
	  if user clicked Ok,then @ok would be set to true.
	  method returns the value user selected when clicke Ok.


Chapter 5 : Managing Events,Custom Signals,and Slots
    Event is the message passing around from the windowing system to the application.
    In Qt,all events that occur are encapsulated in objects that inherit from the QEvent abstract class.
    change in the state of application will be noticed,and a QEvent object would be created and represent it.
    the QEvent object will be delivered to the objects that inherit from QObject by Application event loop.
    Qt event could be handled that alike of Linux signal.

    Qt Event have different types were represented.

    Event handlers :
      QObject has the method event(),which receives events.
      subclass can redefines event handler and reimplement it.(i.e. moveEvent(), timerEvent(), ... !protected member)

      <QtGui/QWindow>
        virtual void moveEvent(QMoveEvent *);
      <QtWidgets/QWidget>
        virtual void moveEvent(QMoveEvent *event);
      move event handler named moveEvent and it is a virtual member method,so subclass could redefines it and 
      reimplement it.

      <QtCore/QObject>
        virtual void timerEvent(QTimerEvent *event);
      timer event handler.

      for produce timer event have to use function QObject::startTimer() to start a timer,after timer expired,
      the timer event would be passed to application.

      <QtCore/QObject>
        int QObject::startTimer(int interval, Qt::TimerType timerType = Qt::CoarseTimer);
	int QObject::startTimer(std::chrono::milliseconds time, Qt::TimerType timerType = Qt::CoarseTimer);
	  these methods will start a timer,time limit expired event would occurs after @interval seconds or 
	  @time milliseconds.

      move event will occurs when move application window.the event encapsulated in QEvent object contains some additional messages.
        inline const QPoint & QMoveEvent::pos() const;
      	inline const QPoint & QMoveEvent::oldPos() const;
	  this member method is used to extract the QPoint object of current window.
	  then call method x() or y() on the QPoint object for get coordinate of current window.
	  oldPos() returns the older QPoint object reference.
	  

	
	  
      

      


	  

      
	    

	  
	  
	    
      